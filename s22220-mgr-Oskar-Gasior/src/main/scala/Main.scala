import best_practices.{ImmutableVariables, MutableVariables, NotUsingNulls, UseOption}
import functional_style.{PolymorphicFunctions, Recursion}
//import functional_style.BriefComparison.formatArgsPureFunction
import functional_style.higher_order_functions.HigherOrderFunctions
import jdk.internal.org.objectweb.asm.util.Printer

object Main {
  def main(args: Array[String]): Unit = {


    // Example showing problems with mutable variables.
    println(
      "\n___________________________________________________" +
      "\n1. Example showing problems with mutable variables:" +
      "\n---------------------------------------------------")
    println("foo(1): " + MutableVariables.foo(1))
    println("foo(1): " + MutableVariables.foo(1))

    // Better implementation of above problem without var.
    println("\nBetter implementation of above problem without var:")
    println("foo(1): " + ImmutableVariables.foo(1))
    println("foo(1): " + ImmutableVariables.foo(1))

    // Mutable variables - example where using of mutable variables is acceptable
    val mutableVariablesList: List[Int] = List(1,2,3)
    println("\nException from the rule:")
    println("sum(x):  " + MutableVariables.sum(mutableVariablesList))
    println("sum2(x): " + MutableVariables.sum2(mutableVariablesList))

    // Problem with nulls.
    println(
        "\n_______________________" +
        "\n2. Problem with nulls:" +
        "\n-----------------------")
    // When defining val null interpreter does not throw any exception that it is not String.
    val notUsingNullsString: String = NotUsingNulls.x
    // When trying to use a string method ".toLowerCase" there is an NullPointerException.
    println("val of type String: " + notUsingNullsString)
    try {
      println(notUsingNullsString.toLowerCase)
    } catch  {
      case e: NullPointerException => println("Do not use null.")
    }

    // Option usage.
    // In below example I compared parsing String to Double directly from String and via Option.
    val parseStringToDoubleOption: Option[Double] = UseOption.toMyDouble("1.a23")
    println(parseStringToDoubleOption.getOrElse("It's not a Double."))
    try {
      val parseStringToDouble: Double = "1.as23".toDouble
    } catch {
      case e: NumberFormatException => println("It's not a Double.")
    }

    // 3. Recursion
    println(
      "\n_______________________" +
        "\n3. Recursion in Scala:" +
        "\n-----------------------")

    try{
      println(Recursion.factorialRecursion(99999))
    } catch {
      case e: StackOverflowError => println("Too big number for recursion call.")
    }

    // Uncomment below section to see the difference of @tailrec
//    val t0 = System.nanoTime()
//    Recursion.factorialTailRecursion(99999)    // call-by-name
//    val t1 = System.nanoTime()
//    println("Elapsed time for factorialTailRecursion: " + (t1 - t0) + "ns")
//
//    val t2 = System.nanoTime()
//    Recursion.factorialTailRecursionOptimised(99999)   // call-by-name
//    val t3 = System.nanoTime()
//    println("Elapsed time for factorialTailRecursionOptimized: " + (t3 - t2) + "ns")
//    val timeDifferencePercents = 100 * ((t1 - t0) - (t3 - t2)) / (t1 - t0)
//    println(s"TailRecursion with @tailrec optimization is $timeDifferencePercents% faster.")

    // Higher-order functions
    println(
      "\n_______________________" +
        "\n4. Higher-order functions:" +
        "\n-----------------------")
    // Methods formatFactorial and formatAbs can be combined into one more general higher-order function formatResult.
    println("Print generated by two different methods:")
    println(HigherOrderFunctions.formatAbs(-7))
    println(HigherOrderFunctions.formatFactorial(4))
    println("\nPrint generated by one general higher-order function:")
    println(HigherOrderFunctions.formatResult("absolute value", -7, HigherOrderFunctions.absolute))
    println(HigherOrderFunctions.formatResult("factorial", 4, Recursion.factorialTailRecursionOptimised))

    // Polymorphic functions
    println(
      "\n_______________________" +
        "\n5. Polymorphic functions:" +
        "\n-----------------------")
    val arrayOfIntMonomorphic: Int = PolymorphicFunctions.findFirstElementInt(Array(1,2,3), 2)
    val arrayOfIntPolymorphic: Int = PolymorphicFunctions.findFirstElement(Array(1,2,3), (x: Int) => x == 2)
    val arrayOfStringMonomorphic: Int = PolymorphicFunctions
      .findFirstElementString(Array("Tom", "John", "Mike"), "John")
    val arrayOfStringPolymorphic: Int = PolymorphicFunctions
      .findFirstElement(Array("Tom", "John", "Mike"), (x: String) => x == "John")
    println("Result of monomorphic function to find index in Array[Int]: " + arrayOfIntMonomorphic)
    println("Result of polymorphic function to find index in Array[Int]: " + arrayOfIntPolymorphic)
    println("Result of monomorphic function to find index in Array[String]: " + arrayOfStringMonomorphic)
    println("Result of polymorphic function to find index in Array[String]: " + arrayOfStringPolymorphic)
  }
}
