import best_practices.{ImmutableVariables, MutableVariables, NotUsingNulls, UseOption}
import domain_modeling_options.case_class.{PersonCaseClass, PersonClass}
import domain_modeling_options.classes.{UserDefault, UserVal, UserVar}
import domain_modeling_options.companion_object.Kid
import domain_modeling_options.objects.UserObject.newID
import domain_modeling_options.objects.{UserClass, UserObject}
import functional_style.{PolymorphicFunctions, Recursion}
import functional_style.higher_order_functions.HigherOrderFunctions

object Main {
  def main(args: Array[String]): Unit = {


    //1.  Example showing problems with mutable variables.
    println(
      "\n___________________________________________________" +
      "\n1. Mutable variables:" +
      "\n---------------------------------------------------")
    println("foo(1): " + MutableVariables.foo(1))
    println("foo(1): " + MutableVariables.foo(1))

    // Better implementation of above problem without var.
    println("\nBetter implementation of above problem without var:")
    println("foo(1): " + ImmutableVariables.foo(1))
    println("foo(1): " + ImmutableVariables.foo(1))

    // Mutable variables - example where using of mutable variables is acceptable
    val mutableVariablesList: List[Int] = List(1,2,3)
    println("\nException from the rule:")
    println("sum(x):  " + MutableVariables.sum(mutableVariablesList))
    println("sum2(x): " + MutableVariables.sum2(mutableVariablesList))

    // 2. Problem with nulls.
    println(
        "\n_______________________" +
        "\n2. Problem with nulls:" +
        "\n-----------------------")
    // When defining val null interpreter does not throw any exception that it is not String.
    val notUsingNullsString: String = NotUsingNulls.x
    // When trying to use a string method ".toLowerCase" there is an NullPointerException.
    println("val of type String: " + notUsingNullsString)
    try {
      println(notUsingNullsString.toLowerCase)
    } catch  {
      case e: NullPointerException => println("Do not use null.")
    }

    // Option usage.
    // In below example I compared parsing String to Double directly from String and via Option.
    val parseStringToDoubleOption: Option[Double] = UseOption.toMyDouble("1.a23")
    println(parseStringToDoubleOption.getOrElse("It's not a Double."))
    try {
      val parseStringToDouble: Double = "1.as23".toDouble
    } catch {
      case e: NumberFormatException => println("It's not a Double.")
    }

    // 3. Recursion
    println(
      "\n_______________________" +
        "\n3. Recursion in Scala:" +
        "\n-----------------------")

    try{
      println(Recursion.factorialRecursion(99999))
    } catch {
      case e: StackOverflowError => println("Too big number for recursion call.")
    }

    // Uncomment below section to see the difference of @tailrec
//    val t0 = System.nanoTime()
//    Recursion.factorialTailRecursion(99999)    // call-by-name
//    val t1 = System.nanoTime()
//    println("Elapsed time for factorialTailRecursion: " + (t1 - t0) + "ns")
//
//    val t2 = System.nanoTime()
//    Recursion.factorialTailRecursionOptimised(99999)   // call-by-name
//    val t3 = System.nanoTime()
//    println("Elapsed time for factorialTailRecursionOptimized: " + (t3 - t2) + "ns")
//    val timeDifferencePercents = 100 * ((t1 - t0) - (t3 - t2)) / (t1 - t0)
//    println(s"TailRecursion with @tailrec optimization is $timeDifferencePercents% faster.")

    // Higher-order functions
    println(
      "\n_______________________" +
        "\n4. Higher-order functions:" +
        "\n-----------------------")
    // Methods formatFactorial and formatAbs can be combined into one more general higher-order function formatResult.
    println("Print generated by two different methods:")
    println(HigherOrderFunctions.formatAbs(-7))
    println(HigherOrderFunctions.formatFactorial(4))
    println("\nPrint generated by one general higher-order function:")
    println(HigherOrderFunctions.formatResult("absolute value", -7, HigherOrderFunctions.absolute))
    println(HigherOrderFunctions.formatResult("factorial", 4, Recursion.factorialTailRecursionOptimised))

    // Polymorphic functions
    println(
      "\n_______________________" +
        "\n5. Polymorphic functions:" +
        "\n-----------------------")
    val arrayOfIntMonomorphic: Int = PolymorphicFunctions.findFirstElementInt(Array(1,2,3), 2)
    val arrayOfIntPolymorphic: Int = PolymorphicFunctions.findFirstElement(Array(1,2,3), (x: Int) => x == 2)
    val arrayOfStringMonomorphic: Int = PolymorphicFunctions
      .findFirstElementString(Array("Tom", "John", "Mike"), "John")
    val arrayOfStringPolymorphic: Int = PolymorphicFunctions
      .findFirstElement(Array("Tom", "John", "Mike"), (x: String) => x == "John")
    println("Result of monomorphic function to find index in Array[Int]: " + arrayOfIntMonomorphic)
    println("Result of polymorphic function to find index in Array[Int]: " + arrayOfIntPolymorphic)
    println("Result of monomorphic function to find index in Array[String]: " + arrayOfStringMonomorphic)
    println("Result of polymorphic function to find index in Array[String]: " + arrayOfStringPolymorphic)


    // Classes constructor
    println(
      "\n_______________________" +
        "\n6. Classes:" +
        "\n-----------------------")
    val userDefault = new UserDefault("John", "Smith")
    val userVar = new UserVar("John", "Smith")
    val userVal = new UserVal("John", "Smith")

    // userVar has vars in constructor parameters. That is why it is possible to get the parameter and modify it.
    println("\nuserVar.name: " + userVar.name)
    userVar.name = "Matt"
    println("userVar.name after modification: " + userVar.name)

    // userVal has vals in constructor parameters. That is why it is possible to get the parameter
    // but modification is not possible.
    println("\nuserVal.name: " + userVal.name)
    // userVal.name = "Oskar"
    // Output (Error): reassignment to val
    //                     userVal.name = "Oskar"

    println("Default primary constructor: ")
    // It is not possible to get or set constructor parameters as they are private. It is only possible to run the method.
    userDefault.printEmployeeInfo()

    // Case Classes
    println(
      "\n_______________________" +
        "\n7. Case Classes:" +
        "\n-----------------------")
    println()
    val personCaseClass = PersonCaseClass("John", 27)
    val personClass = new PersonClass("John", 27)
    println("toString of class:       " + personClass.toString)
    println("toString of case class:  " + personCaseClass.toString)
    println("unapply of case class:   " + PersonCaseClass.unapply(personCaseClass).get)

    personCaseClass match {
      case PersonCaseClass("James", 27) =>
        // use of unapply in pattern matching
        println("This person is: " + PersonCaseClass.unapply(personCaseClass).get)
      case PersonCaseClass(name, age) =>
        // name and age use unapply method
        println("This person is: " + name + ", " + age + " years old.")
      case _ => println("This is not a person!")
    }

    // Object
    println(
      "\n_______________________" +
        "\n8. Object:" +
        "\n-----------------------")
    // Example with singleton
    // Singleton of object may be confusing as it is possible to create 2 values of object the same as with class.
    val M: UserClass = new UserClass
    val N: UserClass = new UserClass
    val P: UserObject.type = UserObject
    val Q: UserObject.type = UserObject

    // Running a method on created instances.
    val m1: Int = M.newID()
    val n1: Int = N.newID()
    val p1: Int = P.newID()
    val q1: Int = Q.newID()

    println("Values created from Class:\nm1: " + m1)
    println("n1: " + n1)
    println("Values created from Object:\np1: " + p1)
    println("q1: " + q1)

    println("\nReferences to instances of Class and Object:")
    println("M (Class): " + M)
    println("N (Class): " + N)
    println("P (Object): " + P)
    println("Q (Object): " + Q)

    val staticExample: Int = newID()
    println("\nUse of static method from UserObject: " + staticExample)

    // Companion object
    println(
      "\n_______________________" +
        "\n9. Companion object:" +
        "\n-----------------------")

    // 3 different instances of Kid
    val kidClass = new Kid("Adam", 12)
    val kidCompanionObject = Kid
    val kidApply = Kid("Natalie", 14)

    println("Copmpanion Class:                " + kidClass)
    println("Companion object:                " + kidCompanionObject)
    println("Apply from comapnion object:     " + kidApply)

    println("\nA method from companion class:   " + kidClass.greeting())
    print("A method from companion object:  ")
    kidCompanionObject.printFromCompanionObject()

    // Laziness
    println(
      "\n_______________________" +
        "\n10. Laziness:" +
        "\n-----------------------")

    lazy val lazyEvaluationValue: Int = {
      println("Lazy evaluation")
      10
    }
    val eagerEvaluationValue: Int = {
      println("Evaluation")
      10
    }
    val someValue: Int = lazyEvaluationValue





  }
}
